// Code generated by github.com/web-ridge/gqlgen-sqlboiler, DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"fmt"
	"io"
	"strconv"
	"time"
	"sync"
	"errors"
	"bytes"
	"strings"

	"github.com/web-ridge/utils-go/boilergql/v3"
	"github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"


	"github.com/ericlagergren/decimal"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/null/v8"

	"database/sql"
	{{ range $import := .Imports }}
		{{ $import.Alias }} "{{ $import.ImportPath }}"
	{{ end }}
)



{{ range $model := .Models }}

	{{- if .IsInput }}
				
		func {{ .PluralName }}ToBoiler(ctx context.Context, db boil.ContextExecutor, am []*{{ $.Frontend.PackageName }}.{{ .Name }})( []*{{ $.Backend.PackageName }}.{{ .BoilerModel.Name }}) {
			ar := make([]*{{ $.Backend.PackageName }}.{{ .BoilerModel.Name }}, len(am))
			for i,m := range am {
				ar[i] = {{ .Name }}ToBoiler(ctx, db, m)
			}
			return ar
		}

		func {{ .Name }}ToBoiler(ctx context.Context, db boil.ContextExecutor, m *{{ $.Frontend.PackageName }}.{{ .Name }})( *{{ $.Backend.PackageName }}.{{ .BoilerModel.Name }}) {
			if m == nil {
				return nil
			}

			r := &{{ $.Backend.PackageName }}.{{ .BoilerModel.Name }}{
			{{ range $field := .Fields -}}
				{{- if $field.ConvertConfig.IsCustom -}}
					{{- if $field.IsPrimaryID -}}
						{{- $field.BoilerField.Name }} : {{ $field.ConvertConfig.ToBoiler }},
					{{- else if and $field.IsNumberID $field.BoilerField.IsRelation -}}
						{{- $field.BoilerField.Name }} : {{ $field.ConvertConfig.ToBoiler }},
					{{- else if $field.IsRelation -}}
					{{- else -}}
						{{- $field.BoilerField.Name }} : {{ $field.ConvertConfig.ToBoiler }}(m.{{ $field.Name }}),
					{{- end }}
				{{- else if $field.IsRelation -}}
				{{- else -}}
					{{- $field.BoilerField.Name }}: m.{{ $field.Name }},
				{{- end }}
			{{ end }}
			}
			return r
		}

		func {{ .Name }}ToModelM(
			ctx context.Context,
			db boil.ContextExecutor,
			input map[string]interface{},
			m {{ $.Frontend.PackageName }}.{{ .Name }},
		) {{ $.Backend.PackageName }}.M {
			model := {{ .Name }}ToBoiler(ctx, db, &m)
			modelM := {{ $.Backend.PackageName }}.M{}
			for key := range input {
				switch key {
					{{ range $field := .Fields }}
						{{ if $field.IsRelationAndNotForeignKey}}
						{{ else }}
							case "{{ $field.JSONName }}":
							modelM[{{ $.Backend.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{- $field.BoilerField.Name }}] = model.{{ $field.Name }}
						{{ end }}
					{{ end }}
				}
			}
			return modelM
		}
		
		func {{ .Name }}ToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
			var columnsWhichAreSet []string
			for key := range input {
				switch key {
					{{ range $field := .Fields -}}
						case "{{ $field.JSONName }}":
							columnsWhichAreSet = append(columnsWhichAreSet, {{ $.Backend.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{- $field.BoilerField.Name }})
					{{ end -}}
				}
			}
			columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
			return boil.Whitelist(columnsWhichAreSet...)
		}

		{{ $inputModel := . -}}
		{{ if gt (len $.AuthorizationScopes) 0 -}}
		func Validate{{ .Name }}ForeignKeys(
			ctx context.Context,
			db boil.ContextExecutor,
			m *{{ $.Frontend.PackageName }}.{{ .Name }},
		) error {
			if m == nil {
				return nil
			}
			{{- range $field := .Fields }}
				{{- if and $field.IsNumberID $field.BoilerField.IsRelation }}
					{{- $relatedModel := $field.BoilerField.Relationship }}
					{{- /* Count applicable scopes to know if we need validation */ -}}
					{{- $hasAnyScope := false }}
					{{- range $scope := $.AuthorizationScopes }}
						{{- range $relField := $relatedModel.Fields }}
							{{- if eq $relField.Name $scope.BoilerColumnName }}
								{{- if (call $scope.AddHook $relatedModel nil "validateForeignKey") }}
									{{- $hasAnyScope = true }}
								{{- end }}
							{{- end }}
						{{- end }}
					{{- end }}
					{{- if $hasAnyScope }}
						{{- /* Check if field is a pointer by comparing Type with TypeWithoutPointer */ -}}
						{{- $isPointer := ne $field.Type $field.TypeWithoutPointer }}
						{{- if not $isPointer }}
			{
				// Validate {{ $field.Name }} references a {{ $relatedModel.Name }} in user's scope
				exists, err := {{ $.Backend.PackageName }}.{{ $relatedModel.PluralName }}(
					{{ $.Backend.PackageName }}.{{ $relatedModel.Name }}Where.ID.EQ({{ $relatedModel.Name }}ID(m.{{ $field.Name }})),
							{{- range $scope := $.AuthorizationScopes }}
								{{- range $relField := $relatedModel.Fields }}
									{{- if eq $relField.Name $scope.BoilerColumnName }}
										{{- if (call $scope.AddHook $relatedModel nil "validateForeignKey") }}
					{{ $.Backend.PackageName }}.{{ $relatedModel.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)),
										{{- end }}
									{{- end }}
								{{- end }}
							{{- end }}
				).Exists(ctx, db)
				if err != nil {
					return fmt.Errorf("{{ $field.JSONName }}: %w", err)
				}
				if !exists {
					return fmt.Errorf("{{ $field.JSONName }}: referenced {{ $relatedModel.Name }} not found or access denied")
				}
			}
						{{- else }}
			if m.{{ $field.Name }} != nil {
				// Validate {{ $field.Name }} references a {{ $relatedModel.Name }} in user's scope
				exists, err := {{ $.Backend.PackageName }}.{{ $relatedModel.PluralName }}(
					{{ $.Backend.PackageName }}.{{ $relatedModel.Name }}Where.ID.EQ({{ $relatedModel.Name }}ID(*m.{{ $field.Name }})),
							{{- range $scope := $.AuthorizationScopes }}
								{{- range $relField := $relatedModel.Fields }}
									{{- if eq $relField.Name $scope.BoilerColumnName }}
										{{- if (call $scope.AddHook $relatedModel nil "validateForeignKey") }}
					{{ $.Backend.PackageName }}.{{ $relatedModel.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)),
										{{- end }}
									{{- end }}
								{{- end }}
							{{- end }}
				).Exists(ctx, db)
				if err != nil {
					return fmt.Errorf("{{ $field.JSONName }}: %w", err)
				}
				if !exists {
					return fmt.Errorf("{{ $field.JSONName }}: referenced {{ $relatedModel.Name }} not found or access denied")
				}
			}
						{{- end }}
					{{- end }}
				{{- end }}
			{{- end }}
			return nil
		}
		{{- end }}
	{{- end }}
{{- end }}
