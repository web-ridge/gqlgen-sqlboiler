// Code generated by github.com/web-ridge/gqlgen-sqlboiler, DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"fmt"
	"io"
	"strconv"
	"time"
	"sync"
	"errors"
	"bytes"
	"strings"

	"github.com/ericlagergren/decimal"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/null/v8"

	"github.com/web-ridge/utils-go/boilergql/v3"

	"database/sql"
	"github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/rs/zerolog/log"
	{{ range $import := $.Imports }}
		{{ $import.Alias }} "{{ $import.ImportPath }}"
	{{ end }}
)


{{ if .HasRoot }}
	type {{.ResolverType}} struct {
		db *sql.DB
	}

	func New(db *sql.DB) *Resolver {
		return &Resolver{
			db: db,
		}
	}
{{ end }}

const inputKey = "input"

{{ range $resolver := .Resolvers -}}

	{{- if  .IsBatchCreate -}}
	//
	{{- end -}}
	const {{ $resolver.PublicErrorKey }} = "{{ $resolver.PublicErrorMessage }}"

	{{ if $.IsResolverOverridden $resolver.Field.GoFieldName -}}
	// {{ $resolver.Field.GoFieldName }} is overridden by user-defined resolver
	{{ else -}}
	func (r *{{lcFirst $resolver.Object.Name}}{{ucFirst $.ResolverType}}) {{$resolver.Field.GoFieldName}}{{ $.ShortResolverDeclaration  $resolver }}  {



		{{- if .IsSingle }}
			m, err := Fetch{{ .Model.Name }}(ctx, r.db, id, "")
			if err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}
			return {{ .Model.Name }}ToGraphQL(ctx, r.db, m), nil

		{{- end -}}

		{{- if .IsList }}
			mods := Get{{ .Model.Name }}NodePreloadMods(ctx)
			{{ range $scope := $.AuthorizationScopes -}}
				{{- if (call $scope.AddHook $resolver.Model.BoilerModel $resolver "listWhere")   }}
					mods = append(mods, dm.{{ $resolver.Model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)))
				{{- end }}
			{{- end }}

			mods = append(mods, {{.Model.Name}}FilterToMods(filter)...)
			{{- if .IsListBackward }}
				connection, err := {{.Model.Name}}Connection(ctx, r.db, mods, boilergql.NewBackwardPagination(last, before), ordering)
			{{- else }}
				connection, err := {{.Model.Name}}Connection(ctx, r.db, mods, boilergql.NewForwardPagination(first, after), ordering)
			{{- end }}
			if err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}
			return connection, nil
		{{- end -}}

		{{- if .IsCreate }}
			{{- /* ID type conversion: find ID field type in BoilerModel.Fields */ -}}
			{{- $idExpr := "m.ID" -}}
			{{- if .Model.BoilerModel -}}
				{{- range $field := .Model.BoilerModel.Fields -}}
					{{- if eq $field.Name "ID" -}}
						{{- if and (ne $field.Type "uint") (ne $field.Type "string") -}}
							{{- $idExpr = "uint(m.ID)" -}}
						{{- end -}}
					{{- end -}}
				{{- end -}}
			{{- end -}}

			m := {{ .InputModel.Name }}ToBoiler(ctx, r.db, &input)

			{{ if gt (len $.AuthorizationScopes) 0 -}}
			// Validate foreign keys belong to user's scope
			if err := Validate{{ .InputModel.Name }}ForeignKeys(ctx, r.db, &input); err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}
			{{- end }}

			{{ $model := .Model -}}
			{{ range $field := .InputModel.Fields -}}
				{{ if and $field.IsObject $field.BoilerField.IsRelation -}}
					if input.{{ $field.Name }} != nil {
						{{ $field.JSONName }} := {{ $field.BoilerField.Relationship.Name }}CreateInputToBoiler(ctx, r.db, input.{{ $field.Name }})
						{{ range $scope := $.AuthorizationScopes -}}
							{{- if (call $scope.AddHook $field.BoilerField.Relationship $resolver "createRelationInput")   }}
								{{ $field.JSONName }}.{{ $scope.BoilerColumnName }} = {{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)
							{{- end }}
						{{- end }}

						// TODO: create the nested relations of {{ $field.Name }}Input if they exist
						if err := {{ $field.JSONName }}.Insert(ctx, r.db, boil.Infer()); err != nil {
							log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
							return nil, errors.New({{ $resolver.PublicErrorKey }})
						}
						m.{{ $field.Name }}ID = {{ $field.JSONName }}.ID
					}

				{{ end -}}
			{{ end -}}

			{{ range $scope := $.AuthorizationScopes -}}
				{{- if (call $scope.AddHook $resolver.Model.BoilerModel $resolver "createInput")   }}
					m.{{$scope.BoilerColumnName}} = {{$scope.ImportAlias}}.{{$scope.ScopeResolverName}}(ctx)
				{{- end }}
			{{- end }}

			if err := m.Insert(ctx, r.db, boil.Infer()); err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}

			// resolve requested fields after creating
			pM, err := Fetch{{ .Model.Name }}(ctx, r.db, {{ .Model.Name }}IDToGraphQL({{ $idExpr }}), {{ .Model.Name }}PayloadPreloadLevels.{{ .Model.JSONName }})
			if err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}
			return &fm.{{ .Model.Name }}Payload{
				{{ .Model.JSONName }}: {{ .Model.Name }}ToGraphQL(ctx, r.db, pM),
			}, nil

		{{- end -}}

		{{- if .IsUpdate }}
			m := {{ .InputModel.Name }}ToModelM(ctx, r.db, boilergql.GetInputFromContext(ctx, inputKey), input)

			{{ if gt (len $.AuthorizationScopes) 0 -}}
			// Validate foreign keys belong to user's scope
			if err := Validate{{ .InputModel.Name }}ForeignKeys(ctx, r.db, &input); err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}
			{{- end }}

			{{ $resolver := . -}}
			{{ $model := .Model -}}
			{{ range $field := .InputModel.Fields -}}
				{{ if and $field.IsObject $field.BoilerField.IsRelation -}}
					if input.{{ $field.Name }} != nil && input.{{ $field.Name }}ID != nil {
						dbID := {{ $field.BoilerField.Relationship.Name }}ID(*input.{{ $field.Name }}ID)
						nestedM := {{ $field.BoilerField.Relationship.Name }}UpdateInputToModelM(
							ctx,
							r.db,
							boilergql.GetInputFromContext(ctx, "input.{{ $field.JSONName }}"),
							*input.{{ $field.Name }},
						)
						if _, err := dm.{{ $field.BoilerField.Relationship.PluralName }}(
							dm.{{ $field.BoilerField.Relationship.Name }}Where.ID.EQ(dbID),
							{{ range $scope := $.AuthorizationScopes -}}
								{{- if (call $scope.AddHook $field.BoilerField.Relationship $resolver "updateRelationWhere")   }}
									dm.{{ $field.BoilerField.Relationship.Name }}Where.{{ $scope.BoilerColumnName }}.EQ(
										{{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx),
									),
								{{- end }}
							{{- end }}
						).UpdateAll(ctx, r.db, nestedM); err != nil {
							log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
							return nil, errors.New({{ $resolver.PublicErrorKey }})
						}
					}

				{{ end -}}
			{{ end -}}

			dbID := {{ .Model.Name }}ID(id)
			if _, err := dm.{{ .Model.PluralName }}(
				dm.{{ .Model.Name }}Where.ID.EQ(dbID),
				{{ range $scope := $.AuthorizationScopes -}}
					{{- if (call $scope.AddHook $resolver.Model.BoilerModel $resolver "updateWhere")   }}
						dm.{{ $resolver.Model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)),
					{{- end }}
				{{- end }}
			).UpdateAll(ctx, r.db, m); err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}

			// resolve requested fields after updating
			pM, err := Fetch{{ .Model.Name }}(ctx, r.db, id, {{ .Model.Name }}PayloadPreloadLevels.{{ .Model.JSONName }})
			if err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}
			return &fm.{{ .Model.Name }}Payload{
				{{ .Model.JSONName }}: {{ .Model.Name }}ToGraphQL(ctx, r.db, pM),
			}, nil

		{{- end -}}

		{{- if .IsDelete }}
			dbID := {{ .Model.Name }}ID(id)
			mods := []qm.QueryMod{
				dm.{{ .Model.Name }}Where.ID.EQ(dbID),
				{{ range $scope := $.AuthorizationScopes -}}
					{{- if (call $scope.AddHook $resolver.Model.BoilerModel $resolver "deleteWhere")   }}
						dm.{{ $resolver.Model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ(
							{{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx),
						),
					{{- end }}
				{{- end }}
			}
			 if _, err := dm.{{ .Model.PluralName }}(mods...).DeleteAll(ctx, r.db{{$resolver.SoftDeleteSuffix}}); err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}

			return &fm.{{ .Model.Name }}DeletePayload{
				ID: id,
			}, nil

		{{- end -}}

		{{- if .IsBatchCreate }}
		// TODO: Implement batch create
		return nil, nil

		{{- end -}}

		{{- if .IsBatchUpdate }}
			var mods []qm.QueryMod
			{{ range $scope := $.AuthorizationScopes -}}
				{{- if (call $scope.AddHook $resolver.Model.BoilerModel $resolver "batchUpdateWhere")   }}
					mods = append(mods, dm.{{ $resolver.Model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)))
				{{- end }}
			{{- end }}
			mods = append(mods, {{.Model.Name}}FilterToMods(filter)...)

			m := {{ .InputModel.Name }}ToModelM(ctx, r.db, boilergql.GetInputFromContext(ctx, inputKey), input)
			if _, err := dm.{{ .Model.PluralName }}(mods...).UpdateAll(ctx, r.db, m); err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}

			return &fm.{{ .Model.PluralName }}UpdatePayload{
				Ok: true,
			}, nil
		{{- end -}}

		{{- if .IsBatchDelete }}
			var mods []qm.QueryMod
			{{ range $scope := $.AuthorizationScopes -}}
				{{- if (call $scope.AddHook $resolver.Model.BoilerModel $resolver "batchDeleteWhere")   }}
					mods = append(mods, dm.{{ $resolver.Model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)))
				{{- end }}
			{{- end }}
			mods = append(mods, {{.Model.Name}}FilterToMods(filter)...)
			mods = append(mods, qm.Select(dm.{{ .Model.Name }}Columns.ID))
			mods = append(mods, qm.From(dm.{{- .Model.TableNameResolverName }}.{{ .Model.BoilerModel.TableName }}))

			{{- if .Model.HasPrimaryStringID }}
			var IDsToRemove []boilergql.RemovedStringID
			{{- else }}
			var IDsToRemove []boilergql.RemovedID
			{{- end }}
			if err := dm.{{ .Model.PluralName }}(mods...).Bind(ctx, r.db, &IDsToRemove); err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}

			boilerIDs := boilergql.RemovedIDsToBoiler{{.Model.PrimaryKeyType|go}}(IDsToRemove)
			if _, err := dm.{{ .Model.PluralName }}(dm.{{ .Model.Name }}Where.ID.IN(boilerIDs)).DeleteAll(ctx, r.db{{$resolver.SoftDeleteSuffix}}); err != nil {
				log.Error().Err(err).Msg({{ $resolver.PublicErrorKey }})
				return nil, errors.New({{ $resolver.PublicErrorKey }})
			}

			return &fm.{{ .Model.PluralName }}DeletePayload{
				Ids: boilergql.{{.Model.PrimaryKeyType|go}}IDsToGraphQL(boilerIDs, dm.{{- .Model.TableNameResolverName }}.{{ .Model.BoilerModel.TableName }}),
			}, nil
		{{- end }}
	}
	{{ end -}}

{{ end }}

func (r *queryResolver) Node(ctx context.Context, globalGraphID string) (fm.Node, error) {
	splitID := strings.SplitN(globalGraphID, "-", 1)
	if len(splitID) != 2 {
		return nil, errors.New("could not parse id")
	}

	model := splitID[0]
	switch model {
		{{ range $model := .Models -}}
		{{ if .IsNormal  -}}
		case "{{$model.Name}}":
			return r.{{$model.JSONName}}(ctx, globalGraphID)
		{{ end -}}
		{{ end -}}

		default:
			return nil, errors.New("could not find corresponding model for id")
	}
}


{{ range $object := .Objects -}}
	func (r *{{$.ResolverType}}) {{$object.Name}}() gm.{{ $object.Name }}Resolver { return &{{lcFirst $object.Name}}{{ucFirst $.ResolverType}}{r} }
{{ end }}

{{ range $object := .Objects -}}
	type {{lcFirst $object.Name}}{{ucFirst $.ResolverType}} struct { *{{$.ResolverType}} }
{{ end }}


{{ if (ne .RemainingSource "") }}
    // !!! WARNING !!!
    // The code below was going to be deleted when updating resolvers. It has been copied here so you have
    // one last chance to move it out of harms way if you want. There are two reasons this happens:
	//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
	//    it when you're done.
	//  - You have helper methods in this file. Move them out to keep these resolver files clean.
	{{ .RemainingSource }}
{{ end }}
