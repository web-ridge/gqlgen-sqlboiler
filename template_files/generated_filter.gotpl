// Code generated by github.com/web-ridge/gqlgen-sqlboiler, DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"fmt"
	"io"
	"strconv"
	"time"
	"reflect"
	"unsafe"
	"sync"
	"errors"
	"bytes"
	"strings"
	"github.com/web-ridge/utils-go/boilergql/v3"
	"github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/volatiletech/sqlboiler/v4/drivers"
	"github.com/ericlagergren/decimal"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/null/v8"
	"database/sql"
	{{ range $import := .Imports }}
		{{ $import.Alias }} "{{ $import.ImportPath }}"
	{{ end }}
)



// const regexSign = `'`
const percentSign = `%`
const parentTableStatement = "%v.%v = %v.%v"
func startsWithValue(v string) string { return   v + percentSign   }
func endsWithValue(v string) string   { return   percentSign + v  }
func containsValue(v string) string   { return   percentSign + v + percentSign   }

const emptyString = "''"
const isZero = "0"
const isLike = " LIKE ?"
const in = " IN ?"
const notIn = " NOT IN ?"

func isNullOr(column string, v string) qm.QueryMod {
	return qm.Where("("+column+" IS NULL OR "+column+" != "+v+")")
}

func isNotNullOr(column string, v string) qm.QueryMod {
	return qm.Where("("+column+" IS NOT NULL AND "+column+" != "+v+")")
}

func appendSubQuery(queryMods []qm.QueryMod, q *queries.Query) []qm.QueryMod {
	// TODO: integrate with subquery in sqlboiler if it will be released in the future
	{{- if eq $.PluginConfig.DatabaseDriver "postgres" }}
		// https://github.com/web-ridge/gqlgen-sqlboiler/issues/25 we need this for postgres
		member := reflect.ValueOf(q).Elem().FieldByName("dialect")
		dialectPtr := (**drivers.Dialect)(unsafe.Pointer(member.UnsafeAddr()))
		dialect := **dialectPtr
		dialect.UseIndexPlaceholders = false
		*dialectPtr = &dialect
	{{- end }}

	qs, args := queries.BuildQuery(q)
	qsClean := strings.TrimSuffix(qs, ";")
	return append(queryMods, qm.Where(fmt.Sprintf("EXISTS(%v)", qsClean), args...))
}


func BooleanFilterToMods(m *{{ $.Frontend.PackageName }}.BooleanFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	if m.IsNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNull(column))
	}
	if m.NotNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNotNull(column))
	}
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
	}
	return queryMods
}

func IDFilterToMods(m *{{ $.Frontend.PackageName }}.IDFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	if m.IsNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNull(column))
	}
	if m.NotNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNotNull(column))
	}
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, boilergql.IDToBoiler(*m.EqualTo)))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, boilergql.IDToBoiler(*m.NotEqualTo)))
	}
	if len(m.In) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + in, boilergql.IDsToBoilerInterfaces(m.In)...))
	}
	if len(m.NotIn) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + notIn, boilergql.IDsToBoilerInterfaces(m.NotIn)...))
	}
	return queryMods
}

func StringFilterToMods(m *{{ $.Frontend.PackageName }}.StringFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}

	var queryMods []qm.QueryMod
	if m.IsNullOrEmpty != nil {
		queryMods = append(queryMods, isNullOr(column, emptyString))
	}
	if m.IsEmpty != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, emptyString))
	}
	if m.IsNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNull(column))
	}
	if m.NotNullOrEmpty != nil {
		queryMods = append(queryMods, isNotNullOr(column, emptyString))
	}
	if m.NotEmpty != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, emptyString))
	}
	if m.NotNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNotNull(column))
	}
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
	}

	lowerColumn := "LOWER("+column+")"
	if m.StartWith != nil {
		queryMods = append(queryMods, qm.Where(lowerColumn+isLike, startsWithValue(strings.ToLower(*m.StartWith))))
	}
	if m.EndWith != nil {
		queryMods = append(queryMods, qm.Where(lowerColumn+isLike, endsWithValue(strings.ToLower(*m.EndWith))))
	}
	if m.Contain != nil {
		queryMods = append(queryMods, qm.Where(lowerColumn+isLike, containsValue(strings.ToLower(*m.Contain))))
	}

	if m.StartWithStrict != nil {
		queryMods = append(queryMods, qm.Where(column+isLike, startsWithValue(*m.StartWithStrict)))
	}
	if m.EndWithStrict != nil {
		queryMods = append(queryMods, qm.Where(column+isLike, endsWithValue(*m.EndWithStrict)))
	}
	if m.ContainStrict != nil {
		queryMods = append(queryMods, qm.Where(column+isLike, containsValue(*m.ContainStrict)))
	}

	if len(m.In) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column+in, boilergql.StringsToInterfaces(m.In)...))
	}
	if len(m.NotIn) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column+notIn, boilergql.StringsToInterfaces(m.NotIn)...))
	}
	
	return queryMods
}


func FloatFilterToMods(m *{{ $.Frontend.PackageName }}.FloatFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	if m.IsNullOrZero != nil {
		queryMods = append(queryMods, isNullOr(column, isZero))
	}
	if m.IsNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNull(column))
	}
	if m.NotNullOrZero != nil {
		queryMods = append(queryMods, isNotNullOr(column, isZero))
	}
	if m.NotNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNotNull(column))
	}
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
	}
	if m.LessThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LT, *m.LessThan))
	}
	if m.MoreThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GT, *m.MoreThan))
	}
	if m.LessThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LTE, *m.LessThanOrEqualTo))
	}
	if m.MoreThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GTE, *m.MoreThanOrEqualTo))
	}
	if len(m.In) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + in, boilergql.FloatsToInterfaces(m.In)...))
	}
	if len(m.NotIn) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + notIn, boilergql.FloatsToInterfaces(m.NotIn)...))
	}
	return queryMods
}

func IntFilterToMods(m *{{ $.Frontend.PackageName }}.IntFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	if m.IsNullOrZero != nil {
		queryMods = append(queryMods, isNullOr(column, isZero))
	}
	if m.IsNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNull(column))
	}
	if m.NotNullOrZero != nil {
		queryMods = append(queryMods, isNotNullOr(column, isZero))
	}
	if m.NotNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNotNull(column))
	}
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
	}
	if m.LessThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LT, *m.LessThan))
	}
	if m.MoreThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GT, *m.MoreThan))
	}
	if m.LessThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LTE, *m.LessThanOrEqualTo))
	}
	if m.MoreThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GTE, *m.MoreThanOrEqualTo))
	}
	if len(m.In) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + in, boilergql.IntsToInterfaces(m.In)...))
	}
	if len(m.NotIn) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + notIn, boilergql.IntsToInterfaces(m.NotIn)...))
	}
	return queryMods
}


func TimeUnixFilterToMods(m *{{ $.Frontend.PackageName }}.TimeUnixFilter, c string) []qm.QueryMod {
	if m == nil {
		return nil
	}

	{{- if eq $.PluginConfig.DatabaseDriver "postgres" }}
	column := "extract(epoch from (" + c + ")"
	{{- else if eq $.PluginConfig.DatabaseDriver "mysql" }}
	column := "UNIX_TIMESTAMP(" + c + ")"
	{{- end }}

	var queryMods []qm.QueryMod
	if m.IsNullOrZero != nil {
		queryMods = append(queryMods, isNullOr(column, isZero))
	}
	if m.IsNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNull(column))
	}
	if m.NotNullOrZero != nil {
		queryMods = append(queryMods, isNotNullOr(column, isZero))
	}
	if m.NotNull != nil {
		queryMods = append(queryMods, qmhelper.WhereIsNotNull(column))
	}
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
	}
	if m.LessThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LT, *m.LessThan))
	}
	if m.MoreThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GT, *m.MoreThan))
	}
	if m.LessThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LTE, *m.LessThanOrEqualTo))
	}
	if m.MoreThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GTE, *m.MoreThanOrEqualTo))
	}
	return queryMods
}

{{ range $enum := .Enums }}
	{{ if $enum.HasFilter }}
		func {{ .Name }}FilterToMods(m *{{ $.Frontend.PackageName }}.{{ .Name }}Filter, column string) []qm.QueryMod {
			if m == nil {
				return nil
			}

			var queryMods []qm.QueryMod
			if m.IsNull != nil {
				queryMods = append(queryMods, qmhelper.WhereIsNull(column))
			}
			if m.NotNull != nil {
				queryMods = append(queryMods, qmhelper.WhereIsNotNull(column))
			}
			if m.EqualTo != nil {
				queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
			}
			if m.NotEqualTo != nil {
				queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
			}
			if len(m.In) > 0 {
				queryMods = append(queryMods, qm.WhereIn(column+in, {{ .PluralName }}ToInterfaceArray(m.In)...))
			}
			if len(m.NotIn) > 0 {
				queryMods = append(queryMods, qm.WhereIn(column+notIn, {{ .PluralName }}ToInterfaceArray(m.NotIn)...))
			}

			return queryMods
		}
	{{ end }}
{{- end }}

{{ range $model := .Models }}

	{{- if and .IsFilter .HasBoilerModel -}}
		func {{ .Name }}ToMods(m *{{ $.Frontend.PackageName }}.{{ .Name }}) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {

				searchMods := {{ .BoilerModel.Name }}SearchToMods(m.Search)
				filterMods := {{ .BoilerModel.Name }}WhereToMods(m.Where, true, "", "")
				if len(searchMods) > 0 && len(filterMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(searchMods...),
						qm.Expr(filterMods...),
					}
				} else if len(searchMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(searchMods...),
					}
				} else if len(filterMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(filterMods...),
					}
				}
			}
			return nil
		}
		func {{ .BoilerModel.Name }}SearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	{{ end }}
	{{- if and .IsWhere .HasBoilerModel  -}}
		func {{ .Name }}SubqueryToMods(m *{{ $.Frontend.PackageName }}.{{ .Name }}, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := {{ .Name }}ToMods(m, !hasForeignKeyInRoot, parentTable, foreignColumn)
			if len(subQueryMods) > 0 {
				subQuery := {{ $.Backend.PackageName }}.{{.BoilerModel.PluralName}}(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func {{ .Name }}ToMods(m *{{ $.Frontend.PackageName }}.{{ .Name }}, withPrimaryID bool, parentTable string, parentForeignKey string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			{{ $model := . }}
			{{ range $field := .Fields }}
				{{-  if and $field.IsRelation $field.BoilerField.IsRelation }}
					{{- if  $field.IsPlural }}
						queryMods = append(queryMods, {{ $field.TypeWithoutPointer|go }}SubqueryToMods(m.{{ $field.Name }}, "", {{ $.Backend.PackageName }}.TableNames.{{- $model.BoilerModel.TableName }})...)
					{{- else if $field.BoilerField.IsForeignKey }}
						queryMods = append(queryMods, {{ $field.TypeWithoutPointer|go }}SubqueryToMods(m.{{ $field.Name }}, {{ $.Backend.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{ $field.BoilerField.Name }}, {{ $.Backend.PackageName }}.TableNames.{{- $model.BoilerModel.TableName }})...)
					{{- else }}
						queryMods = append(queryMods, {{ $field.TypeWithoutPointer|go }}SubqueryToMods(m.{{ $field.Name }}, "", {{ $.Backend.PackageName }}.TableNames.{{- $model.BoilerModel.TableName }})...)
					{{- end }}
				{{-  else if $field.IsOr  }}
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr({{ $field.TypeWithoutPointer|go }}ToMods(m.Or, true, "", "")...)))
					}
				{{-  else if $field.IsAnd  }}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr({{ $field.TypeWithoutPointer|go }}ToMods(m.And, true, "", "")...))
					}
				{{- else }}
					{{- if  $field.IsPrimaryID }}
					if withPrimaryID {
						queryMods = append(queryMods, {{ $field.TypeWithoutPointer|go }}ToMods(m.{{ $field.Name }}, {{ $.Backend.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{ $field.BoilerField.Name }})...)
					}
					{{- else }}
						queryMods = append(queryMods, {{ $field.TypeWithoutPointer|go }}ToMods(m.{{ $field.Name }}, {{ $.Backend.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{ $field.BoilerField.Name }})...)					
					{{- end }}
				{{- end -}}
			{{ end }}

			if len(queryMods) > 0 && parentTable != "" && parentForeignKey != "" {
				{{ range $field := .Fields }}
					{{-  if and $field.IsRelation $field.BoilerField.IsRelation  -}}
							{{- if  not $field.IsPlural -}}
								{{- if $field.BoilerField.IsForeignKey }}
									if parentTable == {{ $.Backend.PackageName }}.TableNames.{{ $field.Relationship.BoilerModel.TableName }} {
										queryMods = append(queryMods, qm.Where(fmt.Sprintf(parentTableStatement, {{ $.Backend.PackageName }}.TableNames.{{- $model.BoilerModel.TableName }}, {{ $.Backend.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{ $field.BoilerField.Name }}, parentTable, parentForeignKey)))
									}
								{{- end -}}
							{{- else }}
								 if parentTable == {{ $.Backend.PackageName }}.TableNames.{{ $field.Relationship.BoilerModel.TableName }} {
									 queryMods = append(queryMods, qm.Where(fmt.Sprintf(parentTableStatement, {{ $.Backend.PackageName }}.TableNames.{{- $model.BoilerModel.TableName }}, {{ $.Backend.PackageName }}.{{ $model.BoilerModel.Name }}Columns.ID, parentTable, parentForeignKey)))
								 }
						{{- end -}}
					{{- end -}}
				{{ end }}
			}



			return queryMods
		}
	{{ end }}



{{- end }}
