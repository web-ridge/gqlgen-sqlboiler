// Code generated by github.com/web-ridge/gqlgen-sqlboiler, DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"fmt"
	"io"
	"strconv"
	"time"
	"sync"
	"errors"
	"bytes"
	"strings"

	"github.com/web-ridge/utils-go/boilergql/v3"
	"github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"

	"github.com/ericlagergren/decimal"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/null/v8"

	"database/sql"
	{{ range $import := .Imports }}
		{{ $import.Alias }} "{{ $import.ImportPath }}"
	{{ end }}
)

{{ range $model := .Models }}
	{{ if and .IsNormal .BoilerModel -}}

		// Fetch{{ .Name }} fetches a single {{ .Name }} by ID with preloads and authorization
		func Fetch{{ .Name }}(ctx context.Context, db boil.ContextExecutor, id string, preloadLevel string) (*{{ $.Backend.PackageName }}.{{ .BoilerModel.Name }}, error) {
			dbID := {{ .Name }}ID(id)
			mods := Get{{ .Name }}PreloadModsWithLevel(ctx, preloadLevel)
			mods = append(mods, {{ $.Backend.PackageName }}.{{ .Name }}Where.ID.EQ(dbID))
			{{- range $scope := $.AuthorizationScopes }}
				{{- if (call $scope.AddHook $model.BoilerModel nil "singleWhere") }}
			mods = append(mods, {{ $.Backend.PackageName }}.{{ $model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)))
				{{- end }}
			{{- end }}
			return {{ $.Backend.PackageName }}.{{ .PluralName }}(mods...).One(ctx, db)
		}

	{{ end -}}
{{ end }}

{{ range $model := .Models }}
	{{ if .HasCreateInput -}}
		{{ $createInput := .CreateInput -}}

		// Create{{ .Name }} creates a new {{ .Name }} and returns the created record with preloads
		func Create{{ .Name }}(ctx context.Context, db boil.ContextExecutor, input {{ $.Frontend.PackageName }}.{{ $createInput.Name }}, preloadLevel string) (*{{ $.Backend.PackageName }}.{{ .BoilerModel.Name }}, error) {
			m := {{ $createInput.Name }}ToBoiler(ctx, db, &input)

			{{ if gt (len $.AuthorizationScopes) 0 -}}
			// Validate foreign keys belong to user's scope
			if err := Validate{{ $createInput.Name }}ForeignKeys(ctx, db, &input); err != nil {
				return nil, err
			}
			{{- end }}

			{{ range $scope := $.AuthorizationScopes -}}
				{{- if (call $scope.AddHook $model.BoilerModel nil "createInput") }}
			m.{{ $scope.BoilerColumnName }} = {{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)
				{{- end }}
			{{- end }}

			if err := m.Insert(ctx, db, boil.Infer()); err != nil {
				return nil, err
			}

			return Fetch{{ .Name }}(ctx, db, {{ .Name }}IDToGraphQL(m.ID), preloadLevel)
		}

	{{ end -}}
{{ end }}

{{ range $model := .Models }}
	{{ if .HasUpdateInput -}}
		{{ $updateInput := .UpdateInput -}}

		// Update{{ .Name }} updates an existing {{ .Name }} and returns the updated record with preloads
		func Update{{ .Name }}(ctx context.Context, db boil.ContextExecutor, id string, input {{ $.Frontend.PackageName }}.{{ $updateInput.Name }}, preloadLevel string) (*{{ $.Backend.PackageName }}.{{ .BoilerModel.Name }}, error) {
			m := {{ $updateInput.Name }}ToModelM(ctx, db, boilergql.GetInputFromContext(ctx, "input"), input)

			{{ if gt (len $.AuthorizationScopes) 0 -}}
			// Validate foreign keys belong to user's scope
			if err := Validate{{ $updateInput.Name }}ForeignKeys(ctx, db, &input); err != nil {
				return nil, err
			}
			{{- end }}

			dbID := {{ .Name }}ID(id)
			if _, err := {{ $.Backend.PackageName }}.{{ .PluralName }}(
				{{ $.Backend.PackageName }}.{{ .Name }}Where.ID.EQ(dbID),
				{{- range $scope := $.AuthorizationScopes }}
					{{- if (call $scope.AddHook $model.BoilerModel nil "updateWhere") }}
				{{ $.Backend.PackageName }}.{{ $model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)),
					{{- end }}
				{{- end }}
			).UpdateAll(ctx, db, m); err != nil {
				return nil, err
			}

			return Fetch{{ .Name }}(ctx, db, id, preloadLevel)
		}

	{{ end -}}
{{ end }}

{{ range $model := .Models }}
	{{ if and .IsNormal .BoilerModel -}}

		// Delete{{ .Name }} deletes a {{ .Name }} by ID with authorization (hard delete)
		func Delete{{ .Name }}(ctx context.Context, db boil.ContextExecutor, id string) error {
			dbID := {{ .Name }}ID(id)
			_, err := {{ $.Backend.PackageName }}.{{ .PluralName }}(
				{{ $.Backend.PackageName }}.{{ .Name }}Where.ID.EQ(dbID),
				{{- range $scope := $.AuthorizationScopes }}
					{{- if (call $scope.AddHook $model.BoilerModel nil "deleteWhere") }}
				{{ $.Backend.PackageName }}.{{ $model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)),
					{{- end }}
				{{- end }}
			).DeleteAll(ctx, db)
			return err
		}

		{{ if .BoilerModel.HasDeletedAt -}}
		// SoftDelete{{ .Name }} soft deletes a {{ .Name }} by ID with authorization
		func SoftDelete{{ .Name }}(ctx context.Context, db boil.ContextExecutor, id string) error {
			dbID := {{ .Name }}ID(id)
			_, err := {{ $.Backend.PackageName }}.{{ .PluralName }}(
				{{ $.Backend.PackageName }}.{{ .Name }}Where.ID.EQ(dbID),
				{{- range $scope := $.AuthorizationScopes }}
					{{- if (call $scope.AddHook $model.BoilerModel nil "deleteWhere") }}
				{{ $.Backend.PackageName }}.{{ $model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)),
					{{- end }}
				{{- end }}
			).DeleteAll(ctx, db, false)
			return err
		}
		{{- end }}

	{{ end -}}
{{ end }}
