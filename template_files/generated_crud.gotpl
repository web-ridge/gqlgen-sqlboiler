// Code generated by github.com/web-ridge/gqlgen-sqlboiler, DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"fmt"
	"io"
	"strconv"
	"time"
	"sync"
	"errors"
	"bytes"
	"strings"

	"github.com/web-ridge/utils-go/boilergql/v3"
	"github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"

	"github.com/ericlagergren/decimal"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/null/v8"

	"database/sql"
	{{ range $import := .Imports }}
		{{ $import.Alias }} "{{ $import.ImportPath }}"
	{{ end }}
)

{{ range $model := .Models }}
	{{ if and .IsNormal .BoilerModel -}}

		// Fetch{{ .Name }} fetches a single {{ .Name }} by ID with preloads and authorization
		func Fetch{{ .Name }}(ctx context.Context, db boil.ContextExecutor, id string, preloadLevel string) (*{{ $.Backend.PackageName }}.{{ .BoilerModel.Name }}, error) {
			dbID := {{ .Name }}ID(id)
			mods := Get{{ .Name }}PreloadModsWithLevel(ctx, preloadLevel)
			mods = append(mods, {{ $.Backend.PackageName }}.{{ .Name }}Where.ID.EQ(dbID))
			{{- range $scope := $.AuthorizationScopes }}
				{{- if (call $scope.AddHook $model.BoilerModel nil "singleWhere") }}
			mods = append(mods, {{ $.Backend.PackageName }}.{{ $model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)))
				{{- end }}
			{{- end }}
			return {{ $.Backend.PackageName }}.{{ .PluralName }}(mods...).One(ctx, db)
		}

		// Delete{{ .Name }} deletes a {{ .Name }} by ID with authorization (hard delete)
		func Delete{{ .Name }}(ctx context.Context, db boil.ContextExecutor, id string) error {
			dbID := {{ .Name }}ID(id)
			_, err := {{ $.Backend.PackageName }}.{{ .PluralName }}(
				{{ $.Backend.PackageName }}.{{ .Name }}Where.ID.EQ(dbID),
				{{- range $scope := $.AuthorizationScopes }}
					{{- if (call $scope.AddHook $model.BoilerModel nil "deleteWhere") }}
				{{ $.Backend.PackageName }}.{{ $model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)),
					{{- end }}
				{{- end }}
			).DeleteAll(ctx, db)
			return err
		}

		{{ if .BoilerModel.HasDeletedAt -}}
		// SoftDelete{{ .Name }} soft deletes a {{ .Name }} by ID with authorization
		func SoftDelete{{ .Name }}(ctx context.Context, db boil.ContextExecutor, id string) error {
			dbID := {{ .Name }}ID(id)
			_, err := {{ $.Backend.PackageName }}.{{ .PluralName }}(
				{{ $.Backend.PackageName }}.{{ .Name }}Where.ID.EQ(dbID),
				{{- range $scope := $.AuthorizationScopes }}
					{{- if (call $scope.AddHook $model.BoilerModel nil "deleteWhere") }}
				{{ $.Backend.PackageName }}.{{ $model.Name }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)),
					{{- end }}
				{{- end }}
			).DeleteAll(ctx, db, false)
			return err
		}
		{{- end }}

	{{ end -}}
{{ end }}

{{ range $model := .Models }}
	{{ if .IsCreateInput -}}
		{{ $modelName := trimSuffix .Name "CreateInput" -}}

		// Create{{ $modelName }} creates a new {{ $modelName }} and returns the created record with preloads
		func Create{{ $modelName }}(ctx context.Context, db boil.ContextExecutor, input {{ $.Frontend.PackageName }}.{{ .Name }}, preloadLevel string) (*{{ $.Backend.PackageName }}.{{ .BoilerModel.Name }}, error) {
			m := {{ .Name }}ToBoiler(ctx, db, &input)

			{{ if gt (len $.AuthorizationScopes) 0 -}}
			// Validate foreign keys belong to user's scope
			if err := Validate{{ .Name }}ForeignKeys(ctx, db, &input); err != nil {
				return nil, err
			}
			{{- end }}

			{{ range $scope := $.AuthorizationScopes -}}
				{{- if (call $scope.AddHook $model.BoilerModel nil "createInput") }}
			m.{{ $scope.BoilerColumnName }} = {{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)
				{{- end }}
			{{- end }}

			if err := m.Insert(ctx, db, boil.Infer()); err != nil {
				return nil, err
			}

			return Fetch{{ $modelName }}(ctx, db, {{ $modelName }}IDToGraphQL(m.ID), preloadLevel)
		}

	{{ end -}}
{{ end }}

{{ range $model := .Models }}
	{{ if .IsUpdateInput -}}
		{{ $modelName := trimSuffix .Name "UpdateInput" -}}

		// Update{{ $modelName }} updates an existing {{ $modelName }} and returns the updated record with preloads
		func Update{{ $modelName }}(ctx context.Context, db boil.ContextExecutor, id string, input {{ $.Frontend.PackageName }}.{{ .Name }}, preloadLevel string) (*{{ $.Backend.PackageName }}.{{ .BoilerModel.Name }}, error) {
			m := {{ .Name }}ToModelM(ctx, db, boilergql.GetInputFromContext(ctx, "input"), input)

			{{ if gt (len $.AuthorizationScopes) 0 -}}
			// Validate foreign keys belong to user's scope
			if err := Validate{{ .Name }}ForeignKeys(ctx, db, &input); err != nil {
				return nil, err
			}
			{{- end }}

			dbID := {{ $modelName }}ID(id)
			if _, err := {{ $.Backend.PackageName }}.{{ $modelName }}s(
				{{ $.Backend.PackageName }}.{{ $modelName }}Where.ID.EQ(dbID),
				{{- range $scope := $.AuthorizationScopes }}
					{{- if (call $scope.AddHook $model.BoilerModel nil "updateWhere") }}
				{{ $.Backend.PackageName }}.{{ $modelName }}Where.{{ $scope.BoilerColumnName }}.EQ({{ $scope.ImportAlias }}.{{ $scope.ScopeResolverName }}(ctx)),
					{{- end }}
				{{- end }}
			).UpdateAll(ctx, db, m); err != nil {
				return nil, err
			}

			return Fetch{{ $modelName }}(ctx, db, id, preloadLevel)
		}

	{{ end -}}
{{ end }}
